// VillaCare Database Schema
// Uses Neon PostgreSQL with NextAuth.js

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// EXISTING TABLES (from your Neon database)
// ============================================

model cleaner_applications {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String    @db.VarChar(255)
  phone         String    @db.VarChar(20)
  referrer_name String    @db.VarChar(255)
  status        String?   @default("pending") @db.VarChar(20)
  notes         String?
  created_at    DateTime? @default(now()) @db.Timestamptz(6)
  reviewed_at   DateTime? @db.Timestamptz(6)
}

model owner_waitlist {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email      String    @db.VarChar(255)
  town       String    @db.VarChar(100)
  created_at DateTime? @default(now()) @db.Timestamptz(6)
}

// ============================================
// NextAuth.js Required Tables (NEW)
// ============================================

model User {
  id                String    @id @default(cuid())
  name              String?
  email             String?   @unique
  emailVerified     DateTime?
  phone             String?   @unique
  phoneVerified     DateTime?
  password          String?   // Hashed password for email login
  image             String?
  role              UserRole  @default(OWNER)
  preferredLanguage String    @default("en") @db.VarChar(10) // en, es, de, fr, nl, it, pt
  lastLoginAt       DateTime? // Track last login time for admin visibility
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Account Management (pause/delete with retention)
  accountStatus        AccountStatus @default(ACTIVE)
  pausedAt             DateTime?     // When account was paused
  pausedReason         String?       @db.Text // Optional feedback on why they paused
  deletionRequestedAt  DateTime?     // When deletion was requested
  deletionScheduledFor DateTime?     // 30 days after request (actual deletion date)
  deletionReason       String?       // Category: not_using, found_alternative, unhappy, other
  deletionFeedback     String?       @db.Text // Detailed feedback

  accounts               Account[]
  sessions               Session[]
  cleaner                Cleaner?
  owner                  Owner?
  adminConversations     Conversation[]        @relation("AdminConversations")
  supportConversations   SupportConversation[]
  auditLogs              AuditLog[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// VillaCare Domain Models (NEW)
// ============================================

enum UserRole {
  OWNER
  CLEANER
  ADMIN
}

enum AccountStatus {
  ACTIVE           // Normal active account
  PAUSED           // Temporarily deactivated (can reactivate anytime)
  PENDING_DELETION // Requested deletion, in 30-day grace period
}

enum CleanerStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
}

enum FeedbackCategory {
  IDEA
  ISSUE
  PRAISE
  QUESTION
}

enum FeedbackMood {
  LOVE
  LIKE
  MEH
  FRUSTRATED
}

enum FeedbackStatus {
  NEW
  REVIEWED
  PLANNED
  DONE
}

enum TeamJoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model Cleaner {
  id             String        @id @default(cuid())
  userId         String        @unique
  slug           String        @unique
  bio            String?       @db.Text
  reviewsLink    String?
  serviceAreas   String[]
  languages      String[]      @default(["es"]) // Languages the cleaner speaks (en, es, de, fr, nl, it, pt)
  hourlyRate     Decimal       @db.Decimal(10, 2)
  status         CleanerStatus @default(PENDING)
  totalBookings  Int           @default(0)
  rating         Decimal?      @db.Decimal(3, 2)
  reviewCount    Int           @default(0)
  featured       Boolean       @default(false)
  teamLeader     Boolean       @default(false) // Team leaders can manage backup cleaners
  calendarToken  String?       @unique // For ICS feed URL
  teamId         String?       // Team this cleaner belongs to (null = independent)
  referredByCode String?       // Team referral code used during signup

  // Team Verification (new cleaners must be verified by a Team Leader)
  verifiedByTeamLeaderId String?   // The Team Leader who verified this cleaner
  verifiedAt             DateTime? // When the cleaner was verified

  // Google Calendar Integration
  googleCalendarConnected Boolean   @default(false)
  googleCalendarSyncedAt  DateTime?
  calendarSyncStatus      String?   @default("NOT_CONNECTED") // NOT_CONNECTED, PENDING_SETUP, SYNCING, SYNCED, ERROR

  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookings         Booking[]
  reviews          Review[]
  conversations    Conversation[]
  ledTeam          Team?             @relation("TeamLeader")
  memberOfTeam     Team?             @relation("TeamMembers", fields: [teamId], references: [id])
  teamJoinRequests TeamJoinRequest[]
  arrivalPreps     ArrivalPrep[]
  availability     CleanerAvailability[]

  // Team verification relations
  verifiedBy       Cleaner?  @relation("VerifiedBy", fields: [verifiedByTeamLeaderId], references: [id])
  verifiedCleaners Cleaner[] @relation("VerifiedBy")

  // AI Sales Agent
  aiSettings           CleanerAISettings?
  aiUsageLogs          AIUsageLog[]
  conversationSummaries ConversationSummary[]
  pendingOnboardings   PendingOnboarding[]
  responseTrackers     BookingResponseTracker[]
}

model Owner {
  id                 String   @id @default(cuid())
  userId             String   @unique
  trusted            Boolean  @default(false)
  referredBy         String?
  totalBookings      Int      @default(0)
  cleanerRating      Decimal? @db.Decimal(3, 2)
  cleanerReviewCount Int      @default(0)
  referralCode       String   @unique
  referralCredits    Decimal  @default(0) @db.Decimal(10, 2)
  preferredExtras    String[] @default([]) // Remember favorite arrival extras
  adminNotes         String?  @db.Text      // CRM notes (preferences, special instructions)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // AI Nurturing
  derivedName        String?              // Name parsed from email if user.name is null
  welcomeEmailSentAt DateTime?            // Track when welcome email was sent

  user                    User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  properties              Property[]
  bookings                Booking[]
  reviews                 Review[]
  conversations           Conversation[]
  arrivalPreps            ArrivalPrep[]
  publicChatConversations PublicChatConversation[]
  nurturingCampaigns      NurturingCampaign[]
}

model Property {
  id             String   @id @default(cuid())
  ownerId        String
  name           String
  address        String
  bedrooms       Int
  bathrooms      Int
  notes          String?  @db.Text
  keyHolderName  String?  // Neighbour, property manager, etc.
  keyHolderPhone String?  // Phone number for key holder
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  owner         Owner             @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  bookings      Booking[]
  comments      InternalComment[]
  conversations Conversation[]
  arrivalPreps  ArrivalPrep[]
}

model Booking {
  id         String        @id @default(cuid())
  cleanerId  String
  ownerId    String
  propertyId String
  status     BookingStatus @default(PENDING)
  service    String
  price      Decimal       @db.Decimal(10, 2)
  hours      Int
  date       DateTime
  time       String
  notes       String?       @db.Text
  shortCode   String?       @unique // 4-digit reference for WhatsApp commands (e.g., "ACCEPT 1234")
  createdByAI Boolean       @default(false) // Booking created by AI sales agent
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  cleaner  Cleaner  @relation(fields: [cleanerId], references: [id])
  owner    Owner    @relation(fields: [ownerId], references: [id])
  property Property @relation(fields: [propertyId], references: [id])
  review   Review?
  responseTracker BookingResponseTracker?
  events   BookingEvent[]
}

model Review {
  id        String   @id @default(cuid())
  bookingId String   @unique
  cleanerId String
  ownerId   String
  rating    Int
  text      String   @db.Text
  featured  Boolean  @default(false)
  approved  Boolean  @default(false)
  createdAt DateTime @default(now())

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  cleaner Cleaner @relation(fields: [cleanerId], references: [id])
  owner   Owner   @relation(fields: [ownerId], references: [id])
}

// ============================================
// Booking Events (Quick Action & Completion Tracking)
// ============================================

enum BookingEventType {
  RUNNING_LATE    // Cleaner sent "running late" message
  ON_MY_WAY       // Cleaner sent "on my way" message
  ARRIVED         // Cleaner arrived at property (work timer starts)
  ACCESS_HELP     // Cleaner requested access help
  CUSTOM_MESSAGE  // Cleaner sent custom message
  COMPLETED       // Cleaner completed with checklist (work timer stops)
}

model BookingEvent {
  id        String           @id @default(cuid())
  bookingId String
  cleanerId String           // Who triggered the event
  type      BookingEventType

  // Event-specific data (JSON)
  // For RUNNING_LATE: { delayMinutes: 10 }
  // For COMPLETED: { checklist: { doors: true, keys: true, pool: true }, message: "..." }
  data      Json?

  // Track if WhatsApp was opened (we can't track if they actually sent)
  whatsappOpened Boolean @default(true)

  createdAt DateTime @default(now())

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId, createdAt])
  @@index([cleanerId, createdAt])
}

model InternalComment {
  id          String   @id @default(cuid())
  propertyId  String
  cleanerId   String
  cleanerName String
  text        String   @db.Text
  createdAt   DateTime @default(now())

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
}

model Feedback {
  id        String           @id @default(cuid())
  category  FeedbackCategory
  mood      FeedbackMood
  message   String?          @db.Text
  page      String
  userType  String?
  userId    String?
  status    FeedbackStatus   @default(NEW)
  votes     Int              @default(0)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
}

// Investor leads from pitch page
model InvestorLead {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  notes     String?  @db.Text
  createdAt DateTime @default(now())

  @@index([createdAt])
}

// ============================================
// Messaging with Translation
// ============================================

model Conversation {
  id         String   @id @default(cuid())
  ownerId    String?  // Optional: for owner-cleaner conversations
  cleanerId  String
  adminId    String?  // Optional: for admin-cleaner conversations
  propertyId String?  // Optional: link to a specific property
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  owner    Owner?    @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  cleaner  Cleaner   @relation(fields: [cleanerId], references: [id], onDelete: Cascade)
  admin    User?     @relation("AdminConversations", fields: [adminId], references: [id], onDelete: Cascade)
  property Property? @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  messages Message[]

  @@unique([ownerId, cleanerId]) // One conversation per owner-cleaner pair
  @@unique([adminId, cleanerId]) // One conversation per admin-cleaner pair
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String   // User ID of sender
  senderRole     UserRole // OWNER or CLEANER

  // Original message
  originalText   String   @db.Text
  originalLang   String   @db.VarChar(10) // e.g., 'en', 'es', 'de', 'fr'

  // Translated message
  translatedText String?  @db.Text
  translatedLang String?  @db.VarChar(10)

  // Metadata
  isRead         Boolean  @default(false)
  isAIGenerated  Boolean  @default(false)
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
}

// ============================================
// Team Management
// ============================================

model Team {
  id                  String   @id @default(cuid())
  name                String
  leaderId            String   @unique
  referralCode        String   @unique // TEAM-{slug}-{4digits}
  requireCalendarSync Boolean  @default(true) // New members must sync Google Calendar
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  leader            Cleaner                @relation("TeamLeader", fields: [leaderId], references: [id])
  members           Cleaner[]              @relation("TeamMembers")
  joinRequests      TeamJoinRequest[]
  availabilityCache TeamAvailabilityCache[]
  services          TeamService[]
}

// Custom services created by team leaders (available to all team members)
model TeamService {
  id          String   @id @default(cuid())
  teamId      String
  team        Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)

  name        String              // "Pool Cleaning"
  description String?             // "Professional pool maintenance"
  type        TeamServiceType     // CUSTOM or ADDON

  // Pricing
  priceType   TeamServicePriceType  // HOURLY or FIXED
  price       Decimal?  @db.Decimal(10, 2)  // Fixed price (for FIXED type)
  hours       Int?                // Hours estimate (for HOURLY type)

  // Approval
  status      TeamServiceStatus @default(PENDING)

  // Ordering
  sortOrder   Int       @default(0)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([teamId])
  @@index([status])
}

enum TeamServiceType {
  CUSTOM   // Full standalone service
  ADDON    // Extra that attaches to a booking
}

enum TeamServicePriceType {
  HOURLY   // price = hours Ã— hourlyRate
  FIXED    // flat fee
}

enum TeamServiceStatus {
  PENDING   // Awaiting admin approval
  APPROVED  // Live on profile
  REJECTED  // Admin rejected
}

model TeamJoinRequest {
  id          String                @id @default(cuid())
  teamId      String
  cleanerId   String
  status      TeamJoinRequestStatus @default(PENDING)
  message     String?               @db.Text
  createdAt   DateTime              @default(now())
  respondedAt DateTime?

  team    Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  cleaner Cleaner @relation(fields: [cleanerId], references: [id], onDelete: Cascade)

  @@unique([teamId, cleanerId])
}

// Team Calendar - aggregated availability cache for team views
model TeamAvailabilityCache {
  id           String   @id @default(cuid())
  teamId       String
  date         DateTime @db.Date
  memberId     String   // Cleaner ID
  availability Json     // [{startTime, endTime, isAvailable, source, bookingId?, title?}]
  lastUpdated  DateTime @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, date, memberId])
  @@index([teamId, date])
}

// ============================================
// Arrival Prep (I'm Coming Home Feature)
// ============================================

enum ArrivalPrepStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
}

model ArrivalPrep {
  id          String            @id @default(cuid())
  ownerId     String
  propertyId  String
  cleanerId   String
  arrivalDate DateTime
  arrivalTime String            // e.g., "14:00"
  extras      String[]          // ["fridge", "flowers", "linens", "basket"]
  notes       String?           @db.Text
  status      ArrivalPrepStatus @default(PENDING)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  owner    Owner    @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  cleaner  Cleaner  @relation(fields: [cleanerId], references: [id])
}

// ============================================
// Cleaner Availability (Google Calendar Sync)
// ============================================

enum AvailabilitySource {
  MANUAL
  GOOGLE_CALENDAR
  BOOKING
}

model CleanerAvailability {
  id            String             @id @default(cuid())
  cleanerId     String
  date          DateTime           @db.Date
  startTime     String             // "09:00" format
  endTime       String             // "17:00" format
  isAvailable   Boolean            @default(true) // false = blocked/busy
  source        AvailabilitySource @default(MANUAL)
  googleEventId String?            // For synced Google Calendar events
  title         String?            // Optional event title (for display)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  cleaner Cleaner @relation(fields: [cleanerId], references: [id], onDelete: Cascade)

  @@unique([cleanerId, date, startTime, endTime])
  @@index([cleanerId, date])
  @@index([cleanerId, date, isAvailable])
}

// ============================================
// AI Sales Agent
// ============================================

model CleanerAISettings {
  id          String   @id @default(cuid())
  cleanerId   String   @unique
  aiEnabled   Boolean  @default(true)  // AI responds to owner messages
  autoBooking Boolean  @default(true)  // AI can create confirmed bookings
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  cleaner Cleaner @relation(fields: [cleanerId], references: [id], onDelete: Cascade)
}

model AIUsageLog {
  id             String   @id @default(cuid())
  cleanerId      String
  conversationId String
  action         String   // RESPONSE, BOOKING_CREATED
  tokensUsed     Int
  createdAt      DateTime @default(now())

  cleaner Cleaner @relation(fields: [cleanerId], references: [id], onDelete: Cascade)

  @@index([cleanerId, createdAt])
}

model ConversationSummary {
  id             String   @id @default(cuid())
  conversationId String
  cleanerId      String
  summary        String   @db.Text
  bookingCreated Boolean  @default(false)
  bookingId      String?
  createdAt      DateTime @default(now())

  cleaner Cleaner @relation(fields: [cleanerId], references: [id], onDelete: Cascade)

  @@index([cleanerId, createdAt])
}

// ============================================
// Public AI Onboarding (Magic Link Signup)
// ============================================

enum OnboardingStatus {
  PENDING     // Waiting for user to click magic link
  COMPLETED   // User signed up and booking created
  EXPIRED     // Link expired (24 hours)
}

// ============================================
// Notifications
// ============================================

enum NotificationType {
  BOOKING_REQUEST     // New booking needs confirmation
  BOOKING_REMINDER    // Reminder to respond to booking
  BOOKING_ESCALATED   // Booking escalated to team
  BOOKING_AUTO_DECLINED // Booking auto-declined
  BOOKING_CONFIRMED   // Booking was confirmed
  BOOKING_COMPLETED   // Booking was completed
  TEAM_COVERAGE       // Team member covered a booking
  NEW_REVIEW          // New review received
  AI_ACTION           // AI took an action
}

model Notification {
  id          String           @id @default(cuid())
  userId      String           // User to notify
  type        NotificationType
  title       String
  message     String           @db.Text
  data        Json?            // Additional data (bookingId, etc)
  read        Boolean          @default(false)
  actionUrl   String?          // Link to take action
  createdAt   DateTime         @default(now())

  @@index([userId, read, createdAt])
}

// Track booking response deadlines
model BookingResponseTracker {
  id            String   @id @default(cuid())
  bookingId     String   @unique
  cleanerId     String

  // Reminder schedule
  reminder1SentAt  DateTime?  // After 1 hour
  reminder2SentAt  DateTime?  // After 2 hours (also escalate to team)
  escalatedAt      DateTime?  // When team was notified
  autoDeclinedAt   DateTime?  // After 6 hours
  respondedAt      DateTime?  // When cleaner responded

  createdAt     DateTime @default(now())

  booking       Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  cleaner       Cleaner  @relation(fields: [cleanerId], references: [id])

  @@index([cleanerId, createdAt])
}

// Webhook idempotency tracking - prevents duplicate processing
model WebhookEvent {
  id         String   @id @default(cuid())
  messageSid String   @unique // Twilio MessageSid for deduplication
  source     String   @default("twilio") // twilio, stripe, etc.
  processedAt DateTime @default(now())

  @@index([messageSid])
}

model PendingOnboarding {
  id          String            @id @default(cuid())
  cleanerId   String            // Cleaner being booked
  token       String            @unique // Magic link token

  cleaner     Cleaner           @relation(fields: [cleanerId], references: [id])

  // Collected visitor info
  visitorName  String
  visitorPhone String
  visitorEmail String?

  // Property details
  bedrooms     Int
  bathrooms    Int
  outdoorAreas String[]         // ["pool", "garden", "terrace"]
  accessNotes  String?          @db.Text // Key location, gate codes, parking
  address      String?

  // Booking details
  serviceType  String           // regular, deep, arrival
  servicePrice Decimal          @db.Decimal(10, 2)
  serviceHours Int
  preferredDate DateTime
  preferredTime String

  // Status
  status       OnboardingStatus @default(PENDING)
  expiresAt    DateTime         // 24 hours from creation
  createdAt    DateTime         @default(now())
  completedAt  DateTime?

  // Result (after completion)
  userId       String?          // Created user ID
  ownerId      String?          // Created owner ID
  propertyId   String?          // Created property ID
  bookingId    String?          // Created booking ID

  @@index([token])
  @@index([cleanerId, status])
}

// ============================================
// Support Conversations
// ============================================

enum SupportConversationStatus {
  ACTIVE      // Ongoing conversation
  RESOLVED    // Marked as resolved
  ESCALATED   // Needs human attention
}

model SupportConversation {
  id          String                    @id @default(cuid())

  // User context (one of these will be set)
  userId      String?                   // Logged-in user
  userType    String                    // 'owner', 'cleaner', 'visitor'
  userName    String?                   // Display name
  userEmail   String?                   // For follow-up

  // Context
  page        String                    // Page where chat started
  sessionId   String                    // Browser session ID for anonymous users

  // Status
  status      SupportConversationStatus @default(ACTIVE)
  resolvedBy  String?                   // Admin who resolved

  // Summary for admin
  summary     String?                   @db.Text
  sentiment   String?                   // 'positive', 'neutral', 'negative'
  topic       String?                   // AI-detected topic

  createdAt   DateTime                  @default(now())
  updatedAt   DateTime                  @updatedAt

  messages    SupportMessage[]
  user        User?                     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@index([status, createdAt])
  @@index([sessionId])
}

model SupportMessage {
  id             String   @id @default(cuid())
  conversationId String

  role           String   // 'user' or 'assistant'
  content        String   @db.Text

  // For assistant messages
  isAI           Boolean  @default(true)

  createdAt      DateTime @default(now())

  conversation   SupportConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
}

// Rate limiting for API endpoints (serverless-compatible)
model RateLimitEntry {
  id        String   @id @default(cuid())
  key       String   // Format: "endpoint:identifier" (e.g. "otp:192.168.1.1")
  createdAt DateTime @default(now())

  @@index([key, createdAt])
}

// ============================================
// Platform Settings (Admin Configurable)
// ============================================

model PlatformSettings {
  id                       String   @id @default("default")
  teamLeaderHoursRequired  Int      @default(50)    // Hours needed to become Team Leader
  teamLeaderRatingRequired Float    @default(5.0)   // Rating needed to become Team Leader

  // Third-party Scripts (loaded on all public pages)
  googleTagManagerId       String?  // GTM container ID (e.g., "GTM-XXXXXXX") - RECOMMENDED
  facebookPixelId          String?  // Facebook Pixel ID (e.g., "123456789012345")
  googleAnalyticsId        String?  // Google Analytics 4 ID for tracking (e.g., "G-XXXXXXXXXX")
  ga4PropertyId            String?  // GA4 Property ID for API access (e.g., "123456789")
  convertBoxScriptId       String?  // ConvertBox script ID
  customHeadScripts        String?  @db.Text // Custom scripts for <head> (JSON array of script objects)
  customBodyScripts        String?  @db.Text // Custom scripts for end of <body> (JSON array)

  updatedAt                DateTime @updatedAt
}

// ============================================
// Applicant Conversations (PENDING cleaners chatting with Team Leaders)
// ============================================

enum ApplicantConversationStatus {
  ACTIVE      // Ongoing conversation
  ACCEPTED    // Team Leader accepted the applicant
  REJECTED    // Team Leader rejected the applicant
}

model ApplicantConversation {
  id               String                      @id @default(cuid())
  applicantId      String                      // PENDING cleaner
  teamLeaderId     String                      // Team Leader they're chatting with (via their profile)

  status           ApplicantConversationStatus @default(ACTIVE)

  // AI-generated summary for Team Leader dashboard
  summary          String?                     @db.Text
  lastSummarizedAt DateTime?

  createdAt        DateTime                    @default(now())
  updatedAt        DateTime                    @updatedAt

  messages         ApplicantMessage[]

  @@unique([applicantId, teamLeaderId]) // One conversation per applicant-teamLeader pair
  @@index([teamLeaderId, status])
  @@index([applicantId])
}

model ApplicantMessage {
  id             String   @id @default(cuid())
  conversationId String

  role           String   // 'user' (applicant) or 'assistant' (AI acting as team leader)
  content        String   @db.Text

  // For tracking original language if translation needed
  originalLang   String?  @db.VarChar(10)

  createdAt      DateTime @default(now())

  conversation   ApplicantConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
}

// ============================================
// Page View Analytics
// ============================================

model PageView {
  id          String   @id @default(cuid())
  path        String   // e.g., "/clara-martinez", "/join", "/"
  cleanerSlug String?  // If viewing a cleaner profile
  referrer    String?  // Where they came from
  userAgent   String?  // Browser/device
  country     String?  // From Vercel headers
  sessionId   String?  // Anonymous session tracking
  userId      String?  // If logged in
  createdAt   DateTime @default(now())

  @@index([path, createdAt])
  @@index([cleanerSlug, createdAt])
  @@index([createdAt])
}

// ============================================
// Audit Log (Admin Activity Tracking)
// ============================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String   // User who performed the action
  action    String   // LOGIN, IMPERSONATE, APPROVE_CLEANER, REJECT_CLEANER, etc.
  target    String?  // ID of affected resource (cleaner ID, review ID, etc.)
  targetType String? // Type of target: CLEANER, OWNER, REVIEW, BOOKING
  details   Json?    // Additional context (old values, new values, etc.)
  ipAddress String?  // IP address of request
  userAgent String?  // Browser/device info
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@index([target, targetType])
}

// ============================================
// AI Owner Nurturing System
// ============================================

// Store public chat conversations for context
model PublicChatConversation {
  id            String   @id @default(cuid())
  sessionId     String   // Browser session ID for anonymous users
  cleanerSlug   String   // Which cleaner's profile page
  ownerId       String?  // Linked after signup

  // Visitor identification (before signup)
  visitorEmail  String?
  visitorPhone  String?
  visitorName   String?

  // AI-generated summary for nurturing context
  summary       String?  @db.Text
  sentiment     String?  // positive, neutral, negative
  topic         String?  // booking_inquiry, pricing, availability, general

  // Tracking
  messageCount  Int      @default(0)
  lastMessageAt DateTime @default(now())
  linkedAt      DateTime? // When linked to owner after signup
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Conversion tracking
  source        String?  // e.g., "homepage-translation-cta", "direct", "referral"
  language      String?  // Detected language of the visitor (e.g., "de", "fr", "en")
  converted     Boolean  @default(false) // True if magic link was created
  convertedAt   DateTime? // When conversion happened

  owner    Owner?               @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  messages PublicChatMessage[]

  @@index([sessionId])
  @@index([visitorEmail])
  @@index([visitorPhone])
  @@index([ownerId])
  @@index([cleanerSlug, createdAt])
  @@index([source])
  @@index([converted])
}

model PublicChatMessage {
  id             String   @id @default(cuid())
  conversationId String
  role           String   // 'user' or 'assistant'
  content        String   @db.Text
  createdAt      DateTime @default(now())

  conversation PublicChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
}

// Types of nurturing emails
enum NurturingEmailType {
  WELCOME              // Sent immediately on signup
  PROFILE_INCOMPLETE   // 2 days after signup if no name/property
  FIRST_BOOKING_PROMPT // 3 days after property added, no booking
  RE_ENGAGEMENT        // 2 weeks no login
}

// Track nurturing emails sent to each owner
model NurturingCampaign {
  id        String             @id @default(cuid())
  ownerId   String
  emailType NurturingEmailType

  // Email content (AI-generated)
  subject   String
  body      String             @db.Text

  // Personalization context used
  context   Json?

  // Tracking
  sentAt    DateTime           @default(now())
  openedAt  DateTime?
  clickedAt DateTime?

  // Result
  messageId String?            // Resend message ID
  error     String?            // If send failed

  owner Owner @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@unique([ownerId, emailType]) // Only one of each type per owner
  @@index([sentAt])
}
